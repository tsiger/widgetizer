/*
This is the runtime script that is injected into the preview iframe.
It is used to update the CSS variables and highlight the widgets.
*/

// Initialize styles for widget highlighting
function initializeHighlightStyles() {
  const style = document.createElement("style");
  style.textContent = `
    [data-widget-id], [data-block-id] {
      transition: outline 0.1s ease-out;
    }
    .widget-highlight {
      outline: 1px solid #0066cc !important;
      position: relative;
      box-shadow: 0 0 10px rgba(0, 102, 204, 0.3);
      z-index: 10;
    }
    .block-highlight {
      outline: 1px solid #22c55e !important;
      position: relative;
      z-index: 11;
    }
    [data-widget-id]:hover {
      outline: 1px dashed rgba(0, 102, 204, 0.5);
      cursor: pointer;
    }
    [data-block-id]:hover {
      outline: 1px dashed rgba(34, 197, 94, 0.5);
      cursor: pointer;
    }
    /* Prevent hover styles on highlighted elements */
    .widget-highlight:hover {
      outline: 1px solid #0066cc !important;
    }
    .block-highlight:hover {
      outline: 1px dashed rgba(34, 197, 94, 0.5);
    }
  `;
  document.head.appendChild(style);
}

// Handle CSS variable updates
function updateCssVariables(variables) {
  // Find the <style id="theme-settings-styles"> tag
  const styleTag = document.getElementById("theme-settings-styles");
  if (!styleTag) {
    console.warn("[PreviewRuntime] Could not find #theme-settings-styles tag");
    return;
  }

  // Build the new CSS content
  const cssString = Object.entries(variables)
    .map(([key, value]) => `${key}: ${value};`)
    .join("\n  ");

  // Update the style tag content
  styleTag.textContent = `:root {\n  ${cssString}\n}`;
}

// Load Google Fonts
function loadFonts(fontsMetadata) {
  // fontsMetadata is an object: { "FontName": [weights array] }
  if (!fontsMetadata || typeof fontsMetadata !== "object" || Object.keys(fontsMetadata).length === 0) {
    return;
  }

  // Construct URL matching server logic
  const base = "https://fonts.googleapis.com/css2";
  const families = Object.entries(fontsMetadata)
    .map(([name, weights]) => {
      const sortedWeights = weights.sort((a, b) => a - b);
      return `family=${encodeURIComponent(name)}:wght@${sortedWeights.join(";")}`;
    })
    .join("&");

  const url = `${base}?${families}&display=swap`;

  // Find existing Google Fonts stylesheet link (generated by {% fonts_stylesheet %})
  // Make sure to get the stylesheet, not the preconnect!
  let link = document.querySelector('link[rel="stylesheet"][href*="fonts.googleapis.com"]');

  if (!link) {
    // If no existing link found, create one
    link = document.createElement("link");
    link.rel = "stylesheet";
    document.head.appendChild(link);
  }

  // Update the href
  link.href = url;
}

// Handle widget highlighting
function highlightWidget(widgetId, blockId) {
  // Remove highlights from OTHER widgets (not the current one)
  document.querySelectorAll("[data-widget-id]").forEach((el) => {
    if (el.getAttribute("data-widget-id") !== widgetId) {
      el.classList.remove("widget-highlight");
    }
  });

  // Remove highlights from OTHER blocks (not the current one)
  document.querySelectorAll("[data-block-id]").forEach((el) => {
    if (el.getAttribute("data-block-id") !== blockId) {
      el.classList.remove("block-highlight");
    }
  });

  // Add/maintain widget highlight
  if (widgetId) {
    const widget = document.querySelector(`[data-widget-id="${widgetId}"]`);
    if (widget) {
      if (!widget.classList.contains("widget-highlight")) {
        widget.classList.add("widget-highlight");
      }

      // Only scroll to widget if no block is selected (i.e., widget was clicked directly)
      if (!blockId) {
        widget.scrollIntoView({ behavior: "smooth", block: "center", inline: "center" });
      }
    }
  }

  // Add/maintain block highlight (no scrolling for blocks)
  if (blockId) {
    const block = document.querySelector(`[data-block-id="${blockId}"]`);
    if (block) {
      if (!block.classList.contains("block-highlight")) {
        block.classList.add("block-highlight");
      }
    }
  }
}

// Scroll to widget without highlighting
function scrollToWidget(widgetId) {
  if (widgetId) {
    const widget = document.querySelector(`[data-widget-id="${widgetId}"]`);
    if (widget) {
      widget.scrollIntoView({ behavior: "smooth", block: "center", inline: "center" });
    }
  }
}

// Message handler
function handleMessage(event) {
  const { type, payload } = event.data;

  switch (type) {
    case "UPDATE_CSS_VARIABLES":
      updateCssVariables(payload);
      break;
    case "LOAD_FONTS":
      loadFonts(payload);
      break;
    case "HIGHLIGHT_WIDGET":
      highlightWidget(payload.widgetId, payload.blockId);
      break;
    case "SCROLL_TO_WIDGET":
      scrollToWidget(payload.widgetId);
      break;
    default:
      console.warn("Preview Runtime: Unknown message type:", type);
  }
}

// Setup interaction handler for widget selection
function setupInteractionHandler() {
  document.addEventListener(
    "click",
    (event) => {
      // Find the closest widget or block element
      const blockEl = event.target.closest("[data-block-id]");
      const widgetEl = event.target.closest("[data-widget-id]");

      if (widgetEl) {
        // Prevent default behavior (e.g., following links)
        event.preventDefault();
        event.stopPropagation();

        const widgetId = widgetEl.getAttribute("data-widget-id");
        const blockId = blockEl ? blockEl.getAttribute("data-block-id") : null;

        // Send message to parent
        window.parent.postMessage(
          {
            type: "WIDGET_SELECTED",
            payload: { widgetId, blockId },
          },
          "*",
        );
      }
    },
    true,
  ); // Use capture phase to ensure we catch it before other handlers
}

// Initialize the preview runtime
function initializeRuntime() {
  initializeHighlightStyles();
  setupInteractionHandler();
  window.addEventListener("message", handleMessage);
}

// TODO: Implement safe widget initialization without eval()
// When widgets are dynamically added, their scripts don't auto-execute
// Consider: asset management, event delegation, or custom init patterns
function initializeWidget(widgetId) {
  // Placeholder - widget scripts currently won't execute on dynamic add
  console.log(`Widget ${widgetId} added - scripts may need manual initialization`);
}

// Create global runtime object
window.PreviewRuntime = {
  initializeRuntime,
  updateCssVariables,
  highlightWidget,
  initializeWidget,
  scrollToWidget,
};

// Auto-initialize when the script loads
initializeRuntime();
